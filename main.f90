!    Copyright (C) 2021  Liwei Fu <liwei.fu@ito.uni-stuttgart.de>
!
!    This file is part of SpeckleSim.
!
!    SpeckleSim is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    SpeckleSim is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!    GNU General Public License for more details.!
! 
! @author: Liwei Fu
	
program main
	use lib_sie_solver_gmres_interface
	use lib_sie_tri_solver_normal	
	use lib_sie_quad_solver_normal	
	use lib_sie_data_container
	use lib_sie_tri_data_container
	
	implicit none
	integer :: file_n, file_start_n
	
	character(len=100) :: str1, str2	
			
	call initalize_calculation()	
	call start_sie_calculation()	
	
	!call test_rotation_matrix_conical_illumination_planewaves
	
	contains
			
	subroutine set_calculation_parameters()
		implicit none
		
		
		!calc_p(1) : illumination type
		!1- Plane wave
		!2- Gaussian beam
		!3- Conical
		!4 - Conical via summing plane wave illuminations
		calc_p(1) = 4
		
		!pay attention to the symmetry of phi (0~pi or 0~2pi)
		if (calc_p(1) .eq. 3) then
			illumination_p%Nt = 21
			illumination_p%Np = 21
			illumination_p%phi_max = 2.0*PI
		else if (calc_p(1) .eq. 4) then
			illumination_p%Nt = 21
			illumination_p%Np = 73
			illumination_p%phi_max = 2*PI
		end if
		
		!When Gaussian beam
		if (calc_p(1) .eq. 2) then		
			beam_waist = 6.0e-6 !waist radius
		else if ((calc_p(1) .eq. 3) .or. (calc_p(1) .eq. 4)) then	
	
			p_obj%r_ph = 1.0e-6
			p_obj%NA = 0.95
			p_obj%M = 100
		end if
		
		!calc_p(2) : calculation type
		!1- tri, triangular element, normal calculation (LU-decomposition) 
		!2- quad, quadrilateral element, normal calculation (LU-decomposition)
		!3- Gmres_tri, MLFMM using GMRES iterative process
		calc_p(2) = 3
		
		!calc_p(3) : formulation type
		!1- 'PMCHWT' 
		!2- 'MCTF'
		!3- 'ICTF'
		!4- 'MCTF2'
		calc_p(3) = 3		
		
		!calc_p(4) : field evaluation plane/method
		!1- 'xz' 
		!2- 'xy'.
		!3- 'yz'
		!4- 'rcs_n',radar cross section n-polarization 
		!5- 'rcs_p', radar cross section p-polarization 
		!6- 'BRDF_n', bidirectional refelction distribution function
		!7- 'BRDF_p', bidirectional refelction distribution function
		!8- 'cyl_field' at position (r, theta)
		calc_p(4) = 1
		
		!Structrual parameters and observation field range and position
		!are set in moudle lib_sie_tri_data_container
		
		!calc_p(5) : object type
		!1- 'sphere'
		!2- 'rough_surface' !generated by matlab		
		!3- 'surface' !rectangular grating meshed by COMSOL		
		!4- 'surface' !sphere meshed by COMSOL		
		!5- 'surface' !cylinder meshed by COMSOL		
		!6- 'surface' !corrugated grating meshed by COMSOL		
		!7- 'surface' !cylindrical hole by COMSOL		
		calc_p(5) = 3 !
		
		
		!calc_p(6) : field evaluation
		!1- surface current or field
		!2- observation field
		!3- both are calculated subsequently	
		calc_p(6) = 3
		
		!calc_p(7) : light propagation direction
		!1- k along the z-axis, the original direction
		!2- k against the z-axis (similar to Tobias Pahl)
		calc_p(7) = 1
		
		if ((calc_p(5) .ge. 3) .and. (calc_p(5) .le. 7))then 
			calc_p(7) = 2
		end if
		!calc_p(8) : polarization
		!1- TM-polarization
		!2- TE-polarization
		calc_p(8) = 1
						
		!Relative permittivity of the surface (object)
		!environment is air
		!eps_r2_main = (-9.7944, -0.313) !(-17.2, -0.498)! (-16.075, -0.442342)!  (2.25, 0.0)!
		!eps_r2_main =  (15.59, -0.2163) !silicon at 600nm !  (18.392, -0.4164) ! at 500nm  !
		!eps_r2_main = (21.8278, 0.8913) ! Si at 450nm according Schinke 2015
		!eps_r2_main = (-5.52, -9.86) ! Nickel at 450nm
		!eps_r2_main = (6.25, 0) ! at 500nm !out of an OE paper: Vol.29, 39249, 2021
		eps_r2_main = (29.6345, -2.7721) ! at 405nm !Poul-Erik's value for Si


		!eps_r2_main =  (2.25, 0.0) ! at 500nm  !glass
		! '1' total field including incident field is calculted
		! '0' only scattered field is calculated			
		total_field = 0			
	end subroutine
	
	subroutine set_structure_and_observation_parameters()	
		real(dp) :: scaling_f, surface_length		
		
		!'sphere' generated by Speckle-Simulator	
		if (calc_p(5) .eq. 1)then			
			!n_disc = 6, 18, 66, 1026, 4098, 16386, 65538, 80500 
			n_disc = 1026
			geometry_p(1) = 0.5e-6 !radius
			geometry_p(2) = 0.0e-9 !unused.			
			surface_length = 2*geometry_p(1)		
		
		!rough_surface generated by matlab			
		else if (calc_p(5) .eq. 2)then	
			surface_length = 7.0e-6
			geometry_p(1) = surface_length !width of the observation field
			geometry_p(2) = surface_length !height of the observation field
			
		!3- 'surface' !grating meshed by COMSOL
		else if (calc_p(5) .eq. 3)then
			surface_length = 10.0e-6 
			geometry_p(1) = 0.60e-6 !grating width
			geometry_p(2) = 0.176e-6 !grating height
			
		!'surface' !sphere meshed by COMSOL	
		else if (calc_p(5) .eq. 4)then
			geometry_p(1) = 0.5e-6 !radius
			geometry_p(2) = 0.0e-9 !
			surface_length = 2*geometry_p(1)
		!'surface' !cylinder meshed by COMSOL
		else if (calc_p(5) .eq. 5)then
			geometry_p(1) = 2.5e-6 !radius
			geometry_p(2) = 2.0e-6 !length of the cylinder
			surface_length = 2*geometry_p(1) !
			
		else if (calc_p(5) .eq. 6)then
			geometry_p(1) = 11.4e-6 !periodicity
			geometry_p(2) = 1.0e-6 !PV value of z
			
			surface_length = geometry_p(1) !	
			geometry_p(3) = surface_length
			
		else if (calc_p(5) .eq. 7)then !cylindrical hole along the z-direction. 
			geometry_p(1) = 0.25e-6 !radius
			geometry_p(2) = 3.0e-6 !length of the cylinder
			surface_length = 2*geometry_p(2) !	
			
		end if
	
		if (calc_p(4) .le. 3)then
			position_c = 0.0e-6
			sampling_na = 1025
			sampling_nb = 3
			scaling_f = 0.5		
			dim_a_min = -10.240e-6! -surface_length*scaling_f
			dim_a_max = 10.24e-6! surface_length*scaling_f
			dim_b_min = -0.3e-6! -surface_length*scaling_f
			dim_b_max = 0.3e-6! surface_length*scaling_f
			
		else if ((calc_p(4) .ge. 4) .and. (calc_p(4) .le. 7)) then
			sampling_na = 501
			sampling_nb = 1
			theta_start = -89.0/180.0*PI 
			theta_end = 89.0/180.0*PI 
			phi_start = 0.0 
			phi_end = 0.0
			position_c = 5.0 !far field observation distance		
		else if (calc_p(4) .eq. 8) then
			scaling_f = 0.5						
			sampling_na = 301 !theta
			sampling_nb = 501 !y		
			position_c = 0.50 !radius of the observation cylinder 
			dim_a_min = -85.0/180.0*PI !angle range 
			dim_a_max  = 85.0/180.0*PI 
			
			surface_length = abs(sin(dim_a_min))*position_c
			!Dimension along the y-direciton
			dim_b_min = -surface_length*scaling_f
			dim_b_max = surface_length*scaling_f
		end if
		
	end subroutine
	
	!Initalize GMRES calculations
	subroutine initalize_gmres()	
	
		x_initial = 0.0				
		tree_s_opt = 120
		truncation_number_default = 13
		max_iterations  = 650
		
		!when restart is not wished
		!set restart large
		restart = max_iterations
		convergence_tolerance = 1.0e-3
		precondition_left =.false. !.true. !
		
		!There is a bug for top_down case
		data_structure_type =  'bottom_up'!'top_down'! 
			
		if (data_structure_type .eq. 'top_down') then
			tree_l_max_predefined = 4			
		end if
		
	end subroutine
	
	!Convention of exp(iwt) for the EM wave
	!Illuminaiton parameters
	!For conical illumination, theta_in = 0
	subroutine set_illumination_parameter()
		implicit none
		
		!theta: incidence angle
		!phi: angle between the xz-plane and the incidence plane
		
		real(dp) :: theta_in, phi_in
		real(dp) :: sign
		real(dp) :: Ein_p(2) 
		
		illumination_p%lambda = 405e-9			
		theta_in = 0.0*PI/180
		phi_in = 0.0*PI/180
		
		!theta and phi are redefined in the conical illumination
		if (calc_p(1) .eq. 3)then
			illumination_p%theta_in = 0.0
			illumination_p%phi_in = 0.0
		else
			illumination_p%theta_in = theta_in
			illumination_p%phi_in = phi_in
		end if
		
		!k along the z-axis
		if (calc_p(7) .eq. 1) then
			sign = 1.0
		elseif (calc_p(7) .eq. 2) then		
			sign = -1.0
				else
			print*, 'Wrong setting for the k-direction!'
		end if
				
		if (calc_p(8) .eq. 1)then !TM-polarization ! It should be Ex and Ey????
			illumination_p%pol = 'TM';
			Ein_p(1) = 1.0
			Ein_p(2) = 0.0		
		else !TE-polarization
			illumination_p%pol = 'TE';
			Ein_p(1) = 0.0
			Ein_p(2) = 1.0
		end if
				
		illumination_p%k_in = &
				(/sin(theta_in)*cos(phi_in), sin(theta_in)*sin(phi_in), sign*cos(theta_in)/)	
				
		! Illumination via microscope				
		call field_rotation_matrix(theta_in, phi_in, Ein_p, sign, illumination_p%E_in)
		
  ! !when only the test input field is calculated:
		!call test_input_field()                      
	
	end subroutine set_illumination_parameter
	
	!According to equation (2) and (5) in Pahl, 2021
	!The same as the one in sie_lib_math
	! Missing sign, added on 04.07.2024
	subroutine field_rotation_matrix(theta, phi, ein_pol, sign, e_in)
		real(dp), intent(in) :: theta, phi
		real(dp), intent(in) :: ein_pol(2)
		real(dp) :: rm(3, 2)
		real(dp), intent(out) :: e_in(3)
		real(dp) :: a, b, c, d
		real(dp) :: sign
		
		a = (-1)*sign*sin(theta)		
		b = cos(theta)
		c = sin(phi)
		d = cos(phi)
		
		rm(1,1) = d**2*b + c**2
		rm(1,2) = c*d*(b-1)
		rm(2,1) = c*d*(b-1)
		rm(2,2) = c**2*b + d**2
		rm(3,1) = a*d
		rm(3,2) = a*c
		!
		e_in(1) = rm(1, 1)*ein_pol(1) + rm(1, 2)*ein_pol(2)
		e_in(2) = rm(2, 1)*ein_pol(1) + rm(2, 2)*ein_pol(2)
		e_in(3) = rm(3, 1)*ein_pol(1) + rm(3, 2)*ein_pol(2)
		
	end subroutine field_rotation_matrix
	
	subroutine initalize_calculation()
	
		call set_calculation_parameters()
		call set_calculation_types()		
	
		if (calc_p(5) .eq. 1) then	
			pre_types%object = 'sphere'
			call name_outputfile_single()			
		else if (calc_p(5) .ge. 2) then	!calc_p(5) = 2, 3, 4, 5, 6
			pre_types%object = 'surface'	
            if (calc_p(1) .eq. 4)then
                write(*,*) 'Give the start-number of files'
                read(*,'(I4.4)') file_start_n
					 print*, 'The start-number of files is', file_start_n
                
					print*, '                           '			
					print*, 'Calculation for a surface'
					print*, '-------------------------'
					!The input name should not include pp_ por tt_
					!If only one file to be calculated, the input name should include .txt
					!if multiple files to be calculated, 
					!the input name should not include '_001.txt'!
					write(*,*) 'Give the file name of the surface'
					read(*,'(A)') file_name_surface    
                
            else
                write(*,*) 'Give the number of files to be calculated'
			    read(*,'(I4.4)') file_n			
			    file_n = file_n -1 			
			    if (file_n .eq. 0)then
				    file_start_n = 1
			    else
				    write(*,*) 'Give the start-number of files'
				    read(*,'(I4.4)') file_start_n
				    if (calc_p(5) .eq. 3)then
					    call read_surface_center_arr()				
				    end if
			    end if
			
			    print*, '                           '			
			    print*, 'Calculation for a surface'
			    print*, '-------------------------'
			    !The input name should not include pp_ por tt_
			    !If only one file to be calculated, the input name should include .txt
			    !if multiple files to be calculated, 
			    !the input name should not include '_001.txt'!
			    write(*,*) 'Give the file name of the surface'
			    read(*,'(A)') file_name_surface                
            end if 			
		else
			print*, 'Not a proper object type'
			call exit
		end if	
		call set_structure_and_observation_parameters()
		call set_illumination_parameter()				

	end subroutine	
	
	!read the surface_center file for grating calculation with scanning
	subroutine read_surface_center_arr()
		character(len = 10) :: dummy
		integer :: m_shift, n_shift, s	
		
		allocate(surface_center_arr(3, 3))	
		surface_center_arr(1, 1:3) = (/0.0, 0.0, 0.0/)
		surface_center_arr(2, 1:3) = (/0.0, 0.0, 0.0/)
		surface_center_arr(3, 1:3) = (/0.0, 0.0, 0.0/)
		
		!open(unit = 206, file = 'surface_center.txt')
		!	read(206, *) dummy, m_shift
		!	read(206, *) dummy, n_shift
		!	allocate(surface_center_arr(m_shift*n_shift, 3))	
		!	do s = 1, n_shift*m_shift				
		!		read(206, *) surface_center_arr(s, 1:3)
		!	end do
		!close(206)		
    end subroutine
    
    !Modified on 15.03.2023, start the calculation for calc_p(1) = 4 at defined nummer of files. 
	 !Modified on 28.03.2024, calc_p(6) = 2 is also included when calc_p(1) = 4
    subroutine start_sie_calculation()
		implicit none
		integer :: m
		integer :: Nt, mm, n
		real(dp), dimension(:,:), allocatable :: angle_arr
		
		!Important for grating simulation
		surface_center = (/0.0, 0.0, 0.0/)
				
		if (calc_p(2) .eq. 1) then
			print*, '                                       '	
			print*, 'Normal calculation using triangular elements'
			print*, '--------------------------------------------'			
			
			if (file_n .gt. 0) then
				do m = file_start_n, file_n+file_start_n
					print*, 'The index of the file is', m
					call name_inputfile_multiple(m)
					call name_outputfile_multiple(m)
					call run_normal_tri_calculation()
				end do
			else 
				call name_outputfile_single()
				call run_normal_tri_calculation()
			end if 	
		else if (calc_p(2) .eq. 2) then		
			print*, '                                       '	
			print*, 'Normal calculation using quadrilateral elements'
			print*, '-------------------------------------------------'					
			
			if (file_n .gt. 0) then
				do m = file_start_n, file_n + file_start_n
					call name_inputfile_multiple(m)
					call name_outputfile_multiple(m)
					call run_normal_quad_calculation()
				end do
			else 
				call name_inputfile_single()
				call name_outputfile_single()
				call run_normal_quad_calculation()
			end if 
		else if (calc_p(2) .eq. 3) then			
			print*, '                                       '	
			print*, 'GMRES solver using triangular elements'
			print*, '------------------------------------------------'		
			call initalize_gmres()
			if (calc_p(1) .eq. 4) then !angle varied
				call name_inputfile_single()	!input and output files
				call prerun_ml_fmm_GMRES_tri_conical_planewaves()
				call conical_illumination_theta_phi_array(angle_arr)
				mm = size(angle_arr(:, 1))                
                
				do n = file_start_n, mm
				    illumination_p%theta_in = angle_arr(n, 2)
				    illumination_p%phi_in = angle_arr(n, 1)										
				    call kin_and_Ein_calculation(calc_p, illumination_p)
				    call name_outputfile_multiple(n)
					 
					 if (calc_p(6) .eq. 2) then
							call lib_sie_tri_solver_normal_II()
					 else if (calc_p(6) .eq. 3) then					
							call lib_sie_solver_gmres_run() !gmres run without precalculation
							call lib_sie_tri_solver_normal_II()
					end if
				end do
			else
				if (file_n .gt. 0) then
					do m = file_start_n, file_n + file_start_n
				
					!For confocal microscope with shifted structure
						if (calc_p(5) .eq. 3) then
							surface_center(1:3) = surface_center_arr(m, 1:3)
						end if 
						call name_inputfile_multiple(m)
						call name_outputfile_multiple(m)
						if (calc_p(6) .eq. 2) then
							call lib_sie_tri_solver_normal_II()
						else if (calc_p(6) .eq. 3) then					
							call run_ml_fmm_GMRES_tri() !gmres run with precalculation
							call lib_sie_tri_solver_normal_II()
						else			
							call run_ml_fmm_GMRES_tri()
						end if
					end do
				else 
					call name_inputfile_single()
					call name_outputfile_single()
					call initalize_gmres()
					if (calc_p(6) .eq. 2) then
						call lib_sie_tri_solver_normal_II()
					else if (calc_p(6) .eq. 3) then
						call run_ml_fmm_GMRES_tri()
						call lib_sie_tri_solver_normal_II()
					else			
						call run_ml_fmm_GMRES_tri()
					end if			
				end if 
			end if		
		end if			
	end subroutine
				
	subroutine conical_illumination_theta_phi_array(angle_arr)
		real(dp) :: NA, dNA, theta_min, theta_max
		real(dp), dimension(:, :), allocatable, intent(out) :: angle_arr		
		integer :: Np, Nt, i, j, m
		
		!dummy
		real(dp) :: phi_min, phi_max, n_air
		real(dp) :: dtheta, dphi, theta, phi
		
		Nt = illumination_p%Nt
		Np = illumination_p%Np
		allocate(angle_arr(Nt*Np, 2))
		
		n_air = 1.0				
		theta_min = 0.0/180*PI				
		theta_max = asin(p_obj%NA/n_air);
		
		phi_min = 0.0/180*PI
		phi_max = illumination_p%phi_max
		
		if (Nt .eq. 1) then
			dtheta = 0
            !theta = theta_min
		else
			dtheta = (theta_max-theta_min)/(Nt-1)	
        end if
		
        if (Np .eq. 1) then
			dphi = 0
            !phi = phi_min
		else
			dphi = (phi_max-phi_min)/(Np-1)
        end if
        	
		
		open (unit = 203, file = 'conical_planewave_theta_phi.txt', action = "write",status = 'replace')		
		
		do j = 1, Np
			phi = phi_min + dphi*(j-1)				
			do i = 1, Nt !
				theta = theta_min + dtheta*(i-1) 
				m = i + (j-1)*Nt
				angle_arr(m, 1) = phi
				angle_arr(m, 2) = theta
				write (203, '(1001(E19.12, tr3))')  angle_arr(m, 1), angle_arr(m, 2)
			end do
		end do
		close(203)
		
	end subroutine
	
	!No correction is necessary
	subroutine set_calculation_types()
		!
		if (calc_p(1) .eq. 1) then	
			pre_types%illumination = 'Plane'! 
			print*, '                              '			
			print*, 'Plane wave illumination'
			print*, '------------------------'
		else if (calc_p(1) .eq. 2) then	
			pre_types%illumination = 'Gaussian'!
			print*, '                              '
			print*, 'Gaussian beam illumination'
			print*, '------------------------'
		else if (calc_p(1) .eq. 3) then		
			pre_types%illumination = 'Conical' !  
			print*, '                              '			
			print*, 'Conical illumination'
			print*, '------------------------'			
		else if (calc_p(1) .eq. 4) then		
			pre_types%illumination = 'Conical_plane' !  
			print*, '                              '			
			print*, 'Conical illumination via plane wave calculations'
			print*, '------------------------'				
		else		
			print*, 'Not a proper illumination type'
		end if
		
		if (calc_p(2) .eq. 1) then	
			pre_types%calculation = 'Normal_tri'
		else if (calc_p(2) .eq. 2) then	
			pre_types%calculation = 'Normal_quad'
		else if (calc_p(2) .eq. 3) then		
			pre_types%calculation = 'Gmres_tri'			
		else
			print*, 'Not a proper calculation type'
		end if
		
		if (calc_p(3) .eq. 1) then	
			pre_types%formulation = 'PMCHWT'
		else if (calc_p(3) .eq. 2) then	
			pre_types%formulation = 'MCTF'
		else if (calc_p(3) .eq. 3) then		
			pre_types%formulation = 'ICTF'
		else if (calc_p(3) .eq. 4) then			
			pre_types%formulation = 'MCTF2'
		else
			print*, 'Not a proper formulation type'
		end if

		if (calc_p(4) .eq. 1) then	
			pre_types%evaluation = 'xz'
		else if (calc_p(4) .eq. 2) then	
			pre_types%evaluation = 'xy'
		else if (calc_p(4) .eq. 3) then		
			pre_types%evaluation = 'yz'
		else if (calc_p(4) .eq. 4) then	
			pre_types%evaluation = 'rcs_n'
		else if (calc_p(4) .eq. 5) then		
			pre_types%evaluation = 'rcs_p'
		else if (calc_p(4) .eq. 6) then		
			pre_types%evaluation = 'BRDF_n'
		else if (calc_p(4) .eq. 7) then		
			pre_types%evaluation = 'BRDF_p'	
		else if (calc_p(4) .eq. 8) then		
			pre_types%evaluation = 'cyl_field'	
		else
			print*, 'Not a proper evaluation type'
		end if
		
	end subroutine
	
	!Multiple surfaces are calculated in one run
	subroutine name_outputfile_multiple(nn)
		integer, intent(in) :: nn

		character(len=8) :: file_nr 
		write(file_nr, '(I4.4)') nn			
		print*, 'The file number for output is', file_nr
		
		if (calc_p(2) .eq. 2)then !quad
			str1 = trim(adjustl(pre_types%formulation))//'_'//trim(file_nr)//'.txt'	
			str2 = trim(adjustl(pre_types%evaluation))//'_'//trim(file_nr)//'.txt'
			file_name_surface = trim(adjustl(file_name_surface))//'_'//trim(file_nr)//'.txt'
			file_name_output_I = 'Result_SEH_quad_'//trim(str1)	
			file_name_output_Efield = 'Result_Efield_quad_'//trim(str2)
		else !GMRES and tri
			if (calc_p(1) .eq. 4) then
				str1 = trim(adjustl(pre_types%formulation))//'.txt'	
				str2 = trim(adjustl(pre_types%evaluation))//'_'//trim(file_nr)//'.txt'	
				file_name_output_I = 'Result_SEH_tri_'//trim(str2)
				file_name_output_Efield = 'Result_Efield_tri_'//trim(str2)			
				print*, 'The file number for output is', file_name_output_Efield
				
				if (calc_p(2) .eq. 3)then
					!str1 = trim(adjustl(pre_types%formulation))//'_'//trim(file_nr)
					file_out_error = 'iteration_error_'//trim(str1)			
					file_out_parameters = 'Calculation_parameters_GMRES_'//trim(str1)//'.txt'	
				else !calc_p(2) = 1
					file_out_parameters = 'Calculation_parameters_normal_'//trim(str1)
				end if
			else
				str1 = trim(adjustl(pre_types%formulation))//'_'//trim(file_nr)//'.txt'	
				str2 = trim(adjustl(pre_types%evaluation))//'_'//trim(file_nr)//'.txt'	
				file_name_output_I = 'Result_SEH_tri_'//trim(str1)
				file_name_output_Efield = 'Result_Efield_tri_'//trim(str2)			
				if (calc_p(2) .eq. 3)then
					str1 = trim(adjustl(pre_types%formulation))//'_'//trim(file_nr)
					file_out_error = 'iteration_error_'//trim(str1)				
					file_out_parameters = 'Calculation_parameters_GMRES_'//trim(str1)//'.txt'	
				else !calc_p(2) = 1
					file_out_parameters = 'Calculation_parameters_normal_'//trim(str1)
				end if
			end if
		end if	!	
    end subroutine
	
    !Input files will be calculated according to enumeration
	subroutine name_inputfile_multiple(nn)
		integer, intent(in) :: nn

		character(len=8) :: file_nr 
		write(file_nr, '(I4.4)') nn			
		if (calc_p(2) .eq. 2)then !quad
			str1 = trim(adjustl(pre_types%formulation))//'_'//trim(file_nr)//'.txt'	
			str2 = trim(adjustl(pre_types%evaluation))//'_'//trim(file_nr)//'.txt'
			file_name_surface = trim(adjustl(file_name_surface))//'_'//trim(file_nr)//'.txt'
			file_name_output_I = 'Result_SEH_quad_'//trim(str1)	
		else !GMRES and tri
			str1 = trim(adjustl(pre_types%formulation))//'_'//trim(file_nr)//'.txt'	
			str2 = trim(adjustl(pre_types%evaluation))//'_'//trim(file_nr)//'.txt'				
			File_NodeCoordinates = 'pp_'//trim(adjustl(file_name_surface))//'_'//trim(file_nr)//'.txt'	
			print*, 'File_NodeCoordinates', File_NodeCoordinates
			File_Element_NodeIndices = 'tt_'//trim(adjustl(file_name_surface))//'_'//trim(file_nr)//'.txt'			
		end if	!	
	end subroutine
	
	subroutine name_outputfile_single()	
		character(len = 10) :: str3, str2, str1
		str1 = trim(adjustl(pre_types%formulation))//'.txt'	
		str2 = trim(adjustl(pre_types%evaluation))//'.txt'	
		
		if (calc_p(2) .eq. 2)then !quad
			str3 = 'quad'			
			file_out_parameters = 'Calculation_parameters_normal_'//trim(str3)//'.txt'
		else
			str3 = 'tri'!//trim(adjustl(pre_types%formulation))
			if (calc_p(2) .eq. 1)then !tri normal
				file_out_parameters = 'Calculation_parameters_normal_'//trim(str3)//'.txt'
			else !(calc_p(2) .eq. 3), GMRES
				file_out_parameters = 'Calculation_parameters_GMRES_'//trim(str3)//'.txt'
				file_out_error = 'iteration_error_'//trim(str3)
			end if!			
		end if		
		file_name_output_I = 'Result_SEH_'//trim(str3)//'_'//trim(str1)
		file_name_output_Efield = 'Result_Efield_'//trim(str3)//'_'//trim(str2)
	end subroutine
	
	subroutine name_inputfile_single()	
		character(len = 10) :: str3
		str1 = trim(adjustl(pre_types%formulation))//'.txt'	
		str2 = trim(adjustl(pre_types%evaluation))//'.txt'	
		
		if (calc_p(2) .eq. 2)then !quad
			str3 = 'quad'
			File_NodeCoordinates = 'pp_'//trim(adjustl(file_name_surface))//'.txt'	
			File_Element_NodeIndices = 'tt_'//trim(adjustl(file_name_surface))//'.txt'	
		else
			str3 = 'tri'!//trim(adjustl(pre_types%formulation))
			File_NodeCoordinates = 'pp_'//trim(adjustl(file_name_surface))
			File_Element_NodeIndices = 'tt_'//trim(adjustl(file_name_surface))
		end if		
	end subroutine
	
	subroutine test_input_field()
	
		type(point), dimension(:), allocatable :: r_local
		
		!dummy
		real(dp ) :: dx_a, dx_b
		
		integer :: i, j, n_a, n_b, m
		type(lib_sie_evaluation_point_type), dimension(:), allocatable :: input_field		
		n_a = sampling_na
		n_b = sampling_nb
		k1 = 2*PI/illumination_p%lambda				
		
		allocate(r_local(n_a*n_b), input_field(n_a*n_b))
		
		dx_a = (dim_a_max - dim_a_min)/(n_a-1)
		dx_b = (dim_b_max - dim_b_min)/(n_b-1)
		do i = 1, n_a
				do j = 1, n_b
				   m = (i-1)*n_a+j
					r_local(m)%point= &
					(/dim_a_max - dx_a*(j-1), position_c, dim_b_max - dx_b*(i-1)/)
					input_field(m)%e_field%vector = illumination_p%E_in*exp(-im*dot_product(k1*illumination_p%k_in, r_local(m)%point))
				end do
		end do
	
		open (unit = 203, file = 'input_field.txt', action = "write",status = 'replace')
			do m = 1, n_a*n_b        
				write (203, '(1001(E19.12, tr3))') 	(real(input_field(m)%e_field%vector(j)), j= 1, 3), &
				(imag(input_field(m)%e_field%vector(j)), j= 1, 3)	
			end do
		close(203)
					
	end subroutine test_input_field
	
	
	subroutine test_rotation_matrix_conical_illumination_planewaves()
		
		!dummy
		complex(dp), dimension(:, :), allocatable :: xx
		real(dp), dimension(:,:), allocatable :: angle_arr
		
		integer :: j, m, n, mm
		
		call set_calculation_parameters()	
		call conical_illumination_theta_phi_array(angle_arr)
		mm = size(angle_arr(:, 1))
		allocate(xx(mm, 3))
		print*, 'mm ist ', mm
				
		do n = 1, mm
			illumination_p%theta_in = angle_arr(n, 2)
			illumination_p%phi_in = angle_arr(n, 1)										
						
			call kin_and_Ein_calculation(calc_p, illumination_p)
			xx(n, :) = dot_product(illumination_p%k_in, illumination_p%E_in)
						
		end do
	
		open (unit = 203, file = 'output_field.txt', action = "write",status = 'replace')
			do m = 1, mm
				write (203, '(1001(E19.12, tr3))') 	(real(xx(m, j)), j= 1, 3), &
				(imag(xx(m,j)), j= 1, 3)	
			end do
		close(203)
					
	end subroutine test_rotation_matrix_conical_illumination_planewaves
	
end program